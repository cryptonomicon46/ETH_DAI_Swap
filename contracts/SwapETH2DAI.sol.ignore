
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;
// import "./UniSwap.sol";
import "hardhat/console.sol";
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
 
contract SwapETH2DAI is FusionToken{
    ISwapRouter public immutable swapRouter;

    address public immutable DAI;
    address public immutable WETH9;
    uint24 constant poolFee = 3000;
    address private _owner;
    mapping (address => uint) private _depositBal;


    // UniSwap private uni = new UniSwap();
    event SwapCompleted(uint _amount);
    event Received(address _sender, uint _value);
    event Deposit(address _payee, uint _value);
    event Withdraw(address _payee, uint _value);
    constructor(address DAI_, 
            address WETH9_,
              ISwapRouter _swapRouter) FusionToken(){

        DAI = DAI_;
        swapRouter = _swapRouter;
        _owner = msg.sender;

    }

    /// @notice owner
    /// @return owner who deployed the SwapETH2DAI contract
    function owner() external view returns (address) {
        return _owner;
    }

    ///@notice checks if the msg.sender is the owner who deployed this contract
    modifier onlyOwner() {
        require(_owner == msg.sender, "Caller is not the owner");
        _;
    }
    function _deposit(address _payee) internal payable onlyOwner() {
        require(msg.value>= "0.1 ether", "INVALID_DEPOSIT_AMOUNT");

        _depositBal[_payee] = _depositBal[_payee].add(msg.value);
        Deposit(_payee,msg.value);
    }


        function _withdraw(address _payee) internal payable onlyOwner() {
        require(_payee != address(0),"INVALID_ACCOUNT");
        require(_depositBal[_payee]>= 0,"NOTHING_TO_WITHDRAW");
        uint _bal  = _depositBal[_payee];
        _depositBal[_payee] = 0;
        (bool success, ) = payable(_payee).call{value: _bal};
        require(success);
        Withdraw(_payee,_bal);
    } 


    /// @notice SwapETHToDai takes in the use's ETH and wraps to WETH before the swap operation to DAI
    /// @dev returns the excess value ETH back to the sender (amountToUse - msg.value)    
    /// Do not use the IWETH interface, define your own ERC20 contract 

    function SwapETHToDai(uint amountToUse) external payable returns (uint amountOut) {
        require(msg.value > 0.1 ether, "ETH_VALUE_TOO_LOW");

        require(msg.value >= amountToUse, "AmountTOSwap_Error");
        console.log("Input ETH Amount=", msg.value);


        //How to convert the incoming ETH to WETH?
        //Create an ERC20 Token called Fusion token. 
        //Upon contract creation, mint FUSION tokens to the owner
        //User sends ETH to the Swap contract, update the balances mapping
        //Create a FUSION/DAI pool on Uniswap testnet
        //Complete the swap  Fusion ERC20 and gets FUSION tokens.
        // Create a pool for FUSION/DAI on Uniswap test net
        //Use this pool to swap out FUSION for DAI
        // Return DAI to the owner along with any ETH balance that wasn't used 

        IWETH(WETH9).deposit{value: msg.value }();
        IERC20(WETH9).approve(address(this), msg.value);

        uint amountInWETH = IERC20(WETH9).balanceOf(msg.sender);

        IERC20(WETH9).transferFrom(WETH9,address(this),amountInWETH);
        amountInWETH = IERC20(WETH9).balanceOf(address(this));
        console.log("Balance of address(this) after",amountInWETH);
      
        IERC20(WETH9).approve(address(swapRouter), amountInWETH );
        uint getRouterAllowance = IERC20(WETH9).allowance(address(this),address(swapRouter));
        console.log("Swap Router's allowance updated to:",getRouterAllowance);

        amountOut = _swapWETHForDai(amountInWETH);
        console.log("amountOut:", amountOut);
        emit SwapCompleted(amountOut);
        
        //Refund excess ETH to User
        uint refundAmount = msg.value - amountToUse;
       (bool sent, ) = msg.sender.call{value: refundAmount}("");
        require(sent, "Refund_Failed");

        //Refund event

    }

    /// @notice swapWETHforDai_EIS (EIS-ExactInputSingle) swaps amountIn tokens to exact amountOut
    /// using the DAI/WETH9 0.3% pool by calling the 
    /// @param amountIn  fixed amount of token input DAI or WETH
    /// @param _amountOut maximum possible output of WET or DAI received
    ///
    function _swapWETHForDai(uint amountIn) internal returns (uint _amountOut) 
    {
        ISwapRouter.ExactInputSingleParams memory params = 
            ISwapRouter.ExactInputSingleParams({
                tokenIn : WETH9,
                tokenOut : DAI,
                fee: poolFee,
                recipient: msg.sender,
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            });
            //Executes the swap
        _amountOut = ISwapRouter(swapRouter).exactInputSingle(params);
        console.log("amountOut=", _amountOut);     
    }

   /// @notice for empty calldata
    // receive() external payable {}

    /// @notice when no other function matches, not even receive
    // fallback() external payable{}
    }